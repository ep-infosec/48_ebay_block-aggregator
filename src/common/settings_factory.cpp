/************************************************************************
Copyright 2021, eBay, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
**************************************************************************/

#include "common/settings_factory.hpp"
#include "common/logging.hpp"
#include "common/utils.hpp"
#include "common/file_command_flags.hpp"
#include "common/urcu_helper.hpp"

#include <flatbuffers/idl.h>
#include <ctime>
#include <fstream>
#include <boost/algorithm/string.hpp>
#include <boost/filesystem.hpp>
#include <boost/filesystem/operations.hpp>
#include <boost/asio/ip/host_name.hpp>
#include <openssl/md5.h>
#include <sstream>

using namespace nucolumnar_aggr::config::v1;

// code generated by cmake inside gen_src/version.cpp
extern const char* getVersion();

/* declaring here since diff_vector calls diff function */
static bool diff(const reflection::Schema* schema, const reflection::Object* schema_object,
                 const flatbuffers::Table* root, const flatbuffers::Table* old_root);

static bool diff_vector(const reflection::Schema* schema, const reflection::Field* field, flatbuffers::VectorOfAny* v1,
                        flatbuffers::VectorOfAny* v2) {
    /* both pointers are null, so return false */
    if (v1 == nullptr && v2 == nullptr)
        return false;

    /* null check and size check */
    if (v1 == nullptr || v2 == nullptr || v1->size() != v2->size())
        return true;

    auto type = field->type()->element();
    switch (type) {
    case reflection::BaseType::Int:
    case reflection::BaseType::UInt:
    case reflection::BaseType::None:
    case reflection::BaseType::UType:
    case reflection::BaseType::Bool:
    case reflection::BaseType::Byte:
    case reflection::BaseType::UByte:
    case reflection::BaseType::Short:
    case reflection::BaseType::UShort:
    case reflection::BaseType::Long:
    case reflection::BaseType::ULong: {
        for (size_t idx = 0; idx < v1->size(); idx++) {
            auto oldval = flatbuffers::GetAnyVectorElemI(v1, type, idx);
            auto newval = flatbuffers::GetAnyVectorElemI(v2, type, idx);
            if (oldval != newval) {
                CVLOG(VMODULE_SETTINGS, 1)
                    << field->name()->str() << ", idx: " << idx << " changed, old: " << oldval << ", new: " << newval;
                return true;
            }
        }
        break;
    }
    case reflection::BaseType::Float:
    case reflection::BaseType::Double: {
        for (size_t idx = 0; idx < v1->size(); idx++) {
            auto oldval = flatbuffers::GetAnyVectorElemF(v1, type, idx);
            auto newval = flatbuffers::GetAnyVectorElemF(v2, type, idx);
            if (oldval != newval) {
                CVLOG(VMODULE_SETTINGS, 1)
                    << field->name()->str() << ", idx: " << idx << " changed, old: " << oldval << ", new: " << newval;
                return true;
            }
        }
        break;
    }
    case reflection::BaseType::String: {
        for (size_t idx = 0; idx < v1->size(); idx++) {
            auto oldval = flatbuffers::GetAnyVectorElemS(v1, type, idx);
            auto newval = flatbuffers::GetAnyVectorElemS(v2, type, idx);
            if (oldval != newval) {
                CVLOG(VMODULE_SETTINGS, 1)
                    << field->name()->str() << ", idx: " << idx << " changed, old: " << oldval << ", new: " << newval;
                return true;
            }
        }
        break;
    }

    case reflection::BaseType::Array:
    case reflection::BaseType::Vector: {
        LOG_ASSERT(false) << "Nested vector not supported as of flatbuffer 1.9.0";
        break;
    }

    case reflection::BaseType::Obj: {
        auto object = (*schema->objects())[field->type()->index()];
        for (size_t idx = 0; idx < v1->size(); idx++) {
            auto restart = diff(schema, object, flatbuffers::GetAnyVectorElemPointer<const flatbuffers::Table>(v1, idx),
                                flatbuffers::GetAnyVectorElemPointer<const flatbuffers::Table>(v2, idx));
            if (restart)
                return true;
        }
        break;
    }

    case reflection::BaseType::Union: {
        // Please do not use unions in settings. It's crazy!
        LOG_ASSERT(false) << "reflection::BaseType::Union type in settings is not supported";
        break;
    }
    }
    return false;
}

static bool diff(const reflection::Schema* schema, const reflection::Object* schema_object,
                 const flatbuffers::Table* root, const flatbuffers::Table* old_root) {
    if (root == nullptr || old_root == nullptr) {
        return root == nullptr && old_root == nullptr;
    }

    for (auto field : *schema_object->fields()) {
        if (field->attributes() != nullptr && field->attributes()->LookupByKey("hotswap") != nullptr) {
            continue;
        }
        switch (field->type()->base_type()) {
        case reflection::BaseType::Int:
        case reflection::BaseType::UInt:
        case reflection::BaseType::None:
        case reflection::BaseType::UType:
        case reflection::BaseType::Bool:
        case reflection::BaseType::Byte:
        case reflection::BaseType::UByte:
        case reflection::BaseType::Short:
        case reflection::BaseType::UShort:
        case reflection::BaseType::Long:
        case reflection::BaseType::ULong: {
            auto a1 = flatbuffers::GetAnyFieldI(*old_root, *field);
            auto a2 = flatbuffers::GetAnyFieldI(*root, *field);
            if (a1 != a2) {
                CVLOG(VMODULE_SETTINGS, 1) << field->name()->str() << " changed, old: " << a1 << ", new: " << a2;
                return true;
            }
            break;
        }

        case reflection::BaseType::Float:
        case reflection::BaseType::Double: {
            auto a1 = flatbuffers::GetAnyFieldF(*old_root, *field);
            auto a2 = flatbuffers::GetAnyFieldF(*root, *field);
            if (a1 != a2) {
                CVLOG(VMODULE_SETTINGS, 1) << field->name()->str() << " changed, old: " << a1 << ", new: " << a2;
                return true;
            }
            break;
        }

        case reflection::BaseType::String: {
            auto s1 = flatbuffers::GetFieldS(*old_root, *field);
            auto s2 = flatbuffers::GetFieldS(*root, *field);
            if (s1 != nullptr && s2 != nullptr && s1->str() != s2->str()) {
                CVLOG(VMODULE_SETTINGS, 1) << field->name()->str() << " changed, old: " << s1 << ", new: " << s2;
                return true;
            }
            break;
        }

        case reflection::BaseType::Array:
        case reflection::BaseType::Vector: {
            auto v1 = flatbuffers::GetFieldAnyV(*old_root, *field);
            auto v2 = flatbuffers::GetFieldAnyV(*root, *field);
            auto restart = diff_vector(schema, field, v1, v2);
            if (restart) {
                CVLOG(VMODULE_SETTINGS, 1)
                    << "Field: " << field->name()->str() << ", vector has different old and new values";
                return true;
            }
            break;
        }

        case reflection::BaseType::Obj: {
            if (field->name()->str() != "processed") {
                auto object = (*schema->objects())[field->type()->index()];
                auto restart = diff(schema, object, flatbuffers::GetFieldT(*root, *field),
                                    flatbuffers::GetFieldT(*old_root, *field));
                if (restart)
                    return true;
            }
            break;
        }

        case reflection::BaseType::Union: {
            // Please do not use unions in settings. It's crazy!
            LOG_ASSERT(false) << "reflection::BaseType::Union type in settings is not supported";
            break;
        }
        }
    }
    return false;
}

namespace nuclm {

static std::string hex_md5(const std::ostringstream& s) {
    auto str = s.str();
    unsigned char d[MD5_DIGEST_LENGTH];
    MD5((const unsigned char*)str.c_str(), str.length(), d);
    return bin2hex(d, sizeof(d));
}

std::string compute_password_digest(const std::string& user_name, const std::string& password) {
    std::ostringstream s1;
    s1 << user_name << ":clickhouse:" << password;
    return hex_md5(s1);
}

extern void grpc_server_tokencache_reset();

static bool check_restart_needed(const NucolumnarAggregatorSettingsT* new_settings,
                                 const NucolumnarAggregatorSettingsT* current_settings) {
    flatbuffers::Parser schemaParser;
    if (!schemaParser.Parse(load_settings_schema().c_str())) {
        LOG(ERROR) << "Error parsing flatbuffer settings schema: " << schemaParser.error_;
        return false;
    }
    schemaParser.Serialize();

    const reflection::Schema* schema = reflection::GetSchema(schemaParser.builder_.GetBufferPointer());
    if (schema->root_table() == nullptr) {
        LOG(INFO) << "schema->root_table() is null in check_restart_needed(..)";
        return false;
    }

    /* Create root_obj for new_settings */
    flatbuffers::Parser new_parser;
    if (!new_parser.Parse(load_settings_schema().c_str())) {
        LOG(ERROR) << "Error parsing flatbuffer settings schema: " << new_parser.error_;
        return false;
    }
    new_parser.builder_.Finish(NucolumnarAggregatorSettings::Pack(new_parser.builder_, new_settings, nullptr));
    auto* root_obj = flatbuffers::GetAnyRoot(new_parser.builder_.GetBufferPointer());

    /* Create root_obj for new_settings */
    flatbuffers::Parser old_parser;
    if (!old_parser.Parse(load_settings_schema().c_str())) {
        LOG(ERROR) << "Error parsing flatbuffer settings schema: " << old_parser.error_;
        return false;
    }
    old_parser.builder_.Finish(NucolumnarAggregatorSettings::Pack(old_parser.builder_, current_settings, nullptr));
    auto* old_root_obj = flatbuffers::GetAnyRoot(old_parser.builder_.GetBufferPointer());

    /* Call diff */
    bool restart = diff(schema, schema->root_table(), root_obj, old_root_obj);
    if (!restart) {
        LOG(INFO) << "check_restart_needed(..) found no changes which need restart";
    } else {
        LOG(INFO) << "check_restart_needed(..) found changes which need restart";
    }

    return restart;
}

struct SecretInfo {
    std::vector<std::string> secrets;
    std::string load_time;
    std::string md5str; // md5 of the content of the secret file as is

    void transfer_if_not_empty(AuthorizationParamsT& params) {
        if (!secrets.empty()) {
            params.secret = std::move(secrets);
            params.loadTime = std::move(load_time);
            params.md5str = std::move(md5str);
        }
    }
    void transfer(AuthorizationParamsT& params) {
        params.secret = std::move(secrets);
        params.loadTime = std::move(load_time);
        params.md5str = std::move(md5str);
    }
};

std::string currentTimeStr() {
    std::time_t t = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    char mbstr[100];
    std::strftime(mbstr, sizeof(mbstr), "%c", std::localtime(&t));
    return mbstr;
}

SecretInfo loadSecret(const std::string& filePath, const char* setting, bool first_time) {
    SecretInfo ret;
    try {
        std::ifstream ifs(filePath);
        std::stringstream cert;
        if (ifs) {
            cert << ifs.rdbuf();
            std::string s = boost::trim_copy(cert.str());
            boost::algorithm::split(ret.secrets, s, boost::is_any_of(" ,\n"), boost::token_compress_on);
            if (ret.secrets.empty()) {
                LOG(ERROR) << "Jwt secret is empty in file " << filePath << " for setting " << setting;
            } else {
                ret.md5str = md5_hex(s.data(), s.length());
                ret.load_time = currentTimeStr();
            }
        } else {
            LOG(ERROR) << "Cannot open authorization secret file: " << filePath << " for setting " << setting;
        }
    } catch (std::exception& e) {
        LOG(ERROR) << e.what() << " for setting " << setting;
    }
    if (ret.secrets.empty()) {
        (first_time ? LOG(FATAL) : LOG(ERROR))
            << "!!!failed to obtain authorization secret!!!: something is wrong with file path '" << filePath
            << "' for setting " << setting;
    }
    return ret;
}

static void parse_vmodule(const std::string& s) {
    std::vector<std::string> tokens;
    boost::algorithm::split(tokens, s, boost::is_any_of(","));
    for (auto token : tokens) {
        std::vector<std::string> kv;
        boost::algorithm::split(kv, token, boost::is_any_of("="));
        LOG(INFO) << "Setting module log level: " << kv[0] << "=" << stoi(kv[1]);
        CHECK_EQ(kv.size(), 2U) << "invalid format of glog vmodule list: <" << s << ">";
        google::SetVLOGLevel(kv[0].c_str(), stoi(kv[1]));
    }
}

static void load_db_credential(NucolumnarAggregatorSettingsT& s, bool exit_if_fail) {
    try {
        std::ifstream u(s.config.databaseServer.dbauth.dbauthUsernamePath),
            p(s.config.databaseServer.dbauth.dbauthPasswordPath);
        if (u.good() && p.good()) {
            std::string user_name = load_file(u);
            std::string password = load_file(p);
            DLOG(INFO) << "Clickhouse Serer authentication is enabled using user '" << user_name << "' and password '"
                       << "<secret>"
                       << "'";
            s.processed.clickhouseUsername = user_name;
            s.processed.clickhousePassword = password;
            s.processed.clickhousePasswordDigest = compute_password_digest(user_name, password);
        } else {
            LOG(ERROR) << "clickhouse server authentication is enabled but unable to read username or password files";
            if (exit_if_fail) {
                exit(-10);
            }
        }
    } catch (std::exception& e) {
        LOG(WARNING) << "Failed to load db credential " << e.what();
    }
}

static void post_process(bool first_time, NucolumnarAggregatorSettingsT& settings) {
    auto& config = *settings.config;

    // Set default log config
    if (config.glog->FLAGS_vmodule.empty()) {
        config.glog->FLAGS_vmodule =
            "admin=2,app=2,http_server=1,metrics=1,rcu=1,settings=1,kafka_consumer=2,aggr_processor=2,aggr_message=2";
    }

    try {
        FLAGS_v = config.glog->FLAGS_v;
        FLAGS_alsologtostderr = config.glog->FLAGS_alsologtostderr;
        FLAGS_logtostderr = config.glog->FLAGS_logtostderr;
        FLAGS_stderrthreshold = config.glog->FLAGS_stderrthreshold;
        FLAGS_logbuflevel = config.glog->FLAGS_logbuflevel;
        FLAGS_max_log_size = config.glog->FLAGS_max_log_size;
        FLAGS_stop_logging_if_full_disk = true;
        FLAGS_log_prefix = true;
        FLAGS_minloglevel = -1; // Log suppression level: messages logged at a lower level than this are suppressed.

        // set FLAGS_vmodule
        parse_vmodule(config.glog->FLAGS_vmodule);
    } catch (std::exception& e) {
        LOG(WARNING) << "Failed to load GLOG config " << e.what();
    }

    if (first_time) {
        auto bindAddress = settings.config->httpServer->bindAddress;
        if (bindAddress == "0.0.0.0" || bindAddress == "::") {
            if (auto& configHostName = settings.config->identity->hostname; !configHostName.empty()) {
                settings.processed->hostname = configHostName;
            } else {
                boost::system::error_code ec;
                settings.processed->hostname = boost::asio::ip::host_name(ec);
                if (settings.processed->hostname.empty()) {
                    settings.processed->hostname = "localhost";
                }
            }
        } else
            settings.processed->hostname = settings.config->httpServer->bindAddress;

        try {
            auto& kafka = *config.kafka;
            settings.processed->authKafkaClient.resize(kafka.configVariants.size());
            size_t idx = 0;
            for (auto& variant : kafka.configVariants) {
                if (variant->secure) {
                    auto& params = *settings.processed->authKafkaClient[idx++];
                    loadSecret(variant->authorizationCert, "kafka active variant authorizationCert", first_time)
                        .transfer_if_not_empty(params);
                    params.subject = variant->subject;
                    params.id = settings.config.identity.replicaName;
                    params.ip = settings.processed->hostname;
                }
                // break;
            }
        } catch (std::exception& e) {
            LOG(WARNING) << "Failed to load kafka config " << e.what();
        }

        if (config.databaseServer.dbauth.dbauth_enabled) {
            load_db_credential(settings, first_time);
        } else {
            LOG(INFO) << "Clickhouse Server authentication is disabled";
        }

        // read admin server secrets file
        auto& httpAuth = *config.httpServer.authorization;
        if (httpAuth.httpAuthorizationEnabled) {
            auto& params = *settings.processed.authHttpServer;
            loadSecret(httpAuth.httpAuthorizationCert, "config->httpServer->authorization->httpAuthorizationCert",
                       first_time)
                .transfer_if_not_empty(params);
            auto& roles = httpAuth.authorizedRoles;
            if (roles.empty()) {
                // the list of authorized roles may be missing due to transitional period when data path auth was
                // introduced but coordinator/agent are not yet managing this setting in config file
                for (auto& r : {"WATCHER", "AGENT", "REMEDYENGINE", "TESTKIT"})
                    params.authorizedRoles.push_back(r);
            } else
                params.authorizedRoles = roles;
        }

        // Read coord client config.
        LOG_SETTINGS(3) << "Loading coordinator client configuration ...";
        auto& coordClient = *config.coordClient;
        if (coordClient.coordAuth.coordAuthorizationEnabled) {
            if (coordClient.coordAuth.coordAuthorizationCert.empty()) {
                coordClient.coordAuth.coordAuthorizationCert = "/nucolumnar/.monstorsecurity/secret.signatures";
                LOG_SETTINGS(3) << "Using default config.coordClient.coordAuth.coordAuthorizationCert = "
                                << coordClient.coordAuth.coordAuthorizationCert;
            } else {
                LOG_SETTINGS(4) << "Using config.coordClient.coordAuth.coordAuthorizationCert = "
                                << coordClient.coordAuth.coordAuthorizationCert;
            }
            auto& params = *settings.processed.authCoordClient;
            LOG_SETTINGS(3) << "Loading coordinator auth secret from " << coordClient.coordAuth.coordAuthorizationCert;

            loadSecret(coordClient.coordAuth.coordAuthorizationCert,
                       "config->coordClient->coordAuth->coordAuthorizationCert", first_time)
                .transfer_if_not_empty(params);
            params.subject = "PROXY";
            params.username = config.identity.replicaName;
            params.ip = config.identity.hostname;
            params.id = params.subject + "-" + params.username + "-" + params.ip;
            params.authorizedRoles.emplace_back("PROXY");
        }

        if (coordClient.coordHost.empty()) {
            LOG(ERROR) << "Local coordinator endpoint is empty";
        }

        LOG_SETTINGS(3) << "Using local coordinator endpoint " << coordClient.coordHost << ":" << coordClient.coordPort;
    }
}

NucolumnarAggregatorSettingsT NuColumnarSettingsFactory::parse_config(NuColumnarSettingsFactory* factory) {
    std::string json_config_str;
    if (!flatbuffers::LoadFile(factory->m_settings_file_path.c_str(), false, &json_config_str)) {
        factory->m_last_error = "flatbuffer::LoadFile() returned false";
        throw std::invalid_argument(factory->m_last_error);
    }

    flatbuffers::Parser parser;
    parser.opts.skip_unexpected_fields_in_json = true;

    if (!parser.Parse(load_settings_schema().c_str())) {
        LOG(ERROR) << "Error parsing flatbuffer settings schema: " << parser.error_;
        factory->m_last_error = parser.error_;
        throw std::invalid_argument(parser.error_);
    }
    if (!parser.Parse(json_config_str.c_str(), nullptr)) {
        LOG(ERROR) << "Error parsing json config: " << parser.error_ << ", content: " << json_config_str;
        factory->m_last_error = parser.error_;
        throw std::invalid_argument(parser.error_);
    }

    // LOG(INFO) << "Previous settings: '" << factory->m_current_settings << "'";

    /* parsing succeeded, update current settings string */
    factory->m_current_settings = std::move(json_config_str);

    // LOG(INFO) << "New settings: '" << factory->m_current_settings << "'";
    google::FlushLogFiles(google::INFO);

    NucolumnarAggregatorSettingsT settings;
    GetNucolumnarAggregatorSettings(parser.builder_.GetBufferPointer())->UnPackTo(&settings, nullptr);

    // Note: the following code has to be executed after settings have been parsed
    // cmd line args should always override the settings from config file
    for (const auto& arg : factory->cmdline->getArgList()) {
        if (arg->getFlag() == "e" && arg->isSet()) {
            auto varg = dynamic_cast<TCLAP::ValueArg<std::string>*>(arg);
            /* This is going to be deprecated from cmd line args.
             *
             * Overriding this arg with the value from settings as per CCOE team's request.
             * This is done to maintain backward compatibility
             * */
            // if (settings.coord->coordEndpoint.size() == 0) {
            //     settings.coord->coordEndpoint = varg->getValue();
            // }
        }
    }

    return settings;
}

void NuColumnarSettingsFactory::load(const std::string& configFilePath) {
    m_settings_file_path = configFilePath;
    try {
        auto new_settings = parse_config(this);
        post_process(true, new_settings);

        std::vector<std::string> files_to_watch;
        files_to_watch.push_back(configFilePath);
        files_to_watch.push_back(new_settings.config->databaseServer->dbauth->dbauthUsernamePath);
        files_to_watch.push_back(new_settings.config->databaseServer->dbauth->dbauthPasswordPath);
        if (!new_settings.config->httpServer->authorization->httpAuthorizationCert.empty()) {
            files_to_watch.push_back(new_settings.config->httpServer->authorization->httpAuthorizationCert);
        }

        if (!new_settings.config->coordClient->coordAuth->coordAuthorizationCert.empty()) {
            files_to_watch.push_back(new_settings.config->coordClient->coordAuth->coordAuthorizationCert);
        }

        m_rcu_data.move_and_exchange(new_settings);

        if (m_file_watcher != nullptr) {
            m_file_watcher->stop();
            m_file_watcher = nullptr;
        }

        m_file_watcher = std::make_unique<FileWatcher>(files_to_watch, [this](const std::vector<fsw::event>& events) {
            bool updated = false;
            for (auto& event : events) {
                auto flags = event.get_flags();
                for (auto& flag : flags) {
                    CVLOG(VMODULE_SETTINGS, 3)
                        << "File event: " << event.get_path() << " " << fsw::event::get_event_flag_name(flag);
                    if (flag == fsw_event_flag::Created || flag == fsw_event_flag::Updated ||
                        flag == fsw_event_flag::Renamed
                        // AttributeModified is for secret symbolic file updates
                        || flag == fsw_event_flag::AttributeModified) {
                        updated = true;
                        LOG(INFO) << "Got an updated file event: " << event.get_path() << " "
                                  << fsw::event::get_event_flag_name(flag);
                    }
                }
            }
            if (updated) {
                reload();
            }
        });

        m_file_watcher->start();

    } catch (std::exception& e) {
        std::stringstream ss;
        ss << "Exception reading config " << get_local_config_file() << "(errmsg = " << e.what() << ") ";
        throw std::runtime_error(ss.str());
    }
}

bool NuColumnarSettingsFactory::reload() {
    try {
        auto new_settings = parse_config(this);
        return exchange_and_notify(new_settings);
    } catch (std::exception& e) {
        LOG(ERROR) << "Exception reading config " << get_local_config_file() << "(errmsg = " << e.what() << ") ";
    }
    return false;
}

std::string NuColumnarSettingsFactory::get_json() const {
    std::string json;
    flatbuffers::Parser parser;
    parser.opts.strict_json = true;
    parser.opts.output_default_scalars_in_json = true;

    if (!parser.Parse(load_settings_schema().c_str())) {
        return std::string{"Error parsing flatbuffer settings schema"};
    }

    parser.builder_.Finish(NucolumnarAggregatorSettings::Pack(parser.builder_, m_rcu_data.get_node()->get(), nullptr));
    if (!GenerateText(parser, parser.builder_.GetBufferPointer(), &json)) {
        return std::string{"Error generating json from flatbuffer"};
    }
    return json;
}

const std::string& NuColumnarSettingsFactory::get_version() const {
    static std::string g_version([]() {
        // set version information
        std::string version{getVersion()};
        std::ifstream in("/nucolumnar/bin/version");
        if (in) {
            std::string tmp;
            in >> tmp;
            version += "(" + tmp + ")";
        }
        return version;
    }());
    return g_version;
}

void NuColumnarSettingsFactory::save(const std::string& filepath) {
    std::string json;
    flatbuffers::Parser parser;
    parser.opts.strict_json = true;

    if (!parser.Parse(load_settings_schema().c_str())) {
        return;
    }

    parser.builder_.Finish(NucolumnarAggregatorSettings::Pack(parser.builder_, m_rcu_data.get_node()->get(), nullptr));
    if (!GenerateTextFile(parser, "", filepath)) {
        return;
    }
}

bool NuColumnarSettingsFactory::exchange_and_notify(NucolumnarAggregatorSettingsT& settings) {
    bool restart = check_restart_needed(&settings, m_rcu_data.get_node()->get());
    post_process(true, settings);
    m_rcu_data.move_and_exchange(settings);
    for (auto& it : m_settings_listeners) {
        try {
            it(settings, restart);
        } catch (...) {
            LOG(ERROR) << "Failed to notify listener: " << boost::current_exception_diagnostic_information(true);
        }
    }
    return restart;
}

void NuColumnarSettingsFactory::stop_file_watcher() {
    if (m_file_watcher != nullptr) {
        m_file_watcher->stop();
    }
}

} // namespace nuclm
